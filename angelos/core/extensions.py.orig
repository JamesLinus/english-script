# encoding: utf-8

def puts(x # debug!):
  print x
  print "\n"
  x

def put(x):
  print x

def grep(xs, x):
  xs.select { |y| y.to_s.match(x) }

def say(x):
  puts x
  system "say '#{x}'" #mac only!

def beep:
  print "\aBEEP "
  system "say 'beep'"
  'beeped'

class Class
  def blank?:
    False


class File
  def to_s:
    path

  def move(to):
    import fileutils
    FileUtils.mv(path, to)

  def contain(x):
    path.index(x)

  def contains(x):
    path.index(x)

  def delete:
    raise SecurityError "cannot delete files"
    #FileUtils.remove_dir(to_path, True)


class Dir
  def to_s:
    path

  def files:
    to_a

  def contains(x):
    select { |f| f == x }
    #Dir.cd
    #  Dir.glob "*.JPG"

  import fileutils

  def remove_leaves(dir=".", matching= ".svn"):
    Dir.chdir(dir) do
      entries=Dir.entries(Dir.pwd).reject { |e| e=="." or e==".." }
      if entries.size == 1 and entries.first == matching:
        puts "Removing #{Dir.pwd}"
        FileUtils.rm_rf(Dir.pwd)
      else
        entries.each do |e|
          if File.directory? e:
            remove_leaves(e)





  def delete:
    raise SecurityError "cannot delete directories"
    #FileUtils.remove_dir(to_path, True)


# class Number < Numeric
# 
def None.blank?:
  return True

def None.test:
  "None.test OK"

#def None.to_s:
#  ""
#  #"None"
#
class Hash
  # filter ==  x.select{|z|z>1}

  # CAREFUL! MESSES with rails etc!!
  alias_method :orig_index, :[]


  # Careful hash.map returns an Array, not a map as expected
  # Therefore we need a(method:)
  # {a:1,b:2}.map_values{|x|x*3} => {a:3,b:6}
  def map_values:
    self.inject({}) do |newhash, (k,v)|
      newhash[k] = yield(v)
      newhash


  def [] x:
    if not x: return
    if isinstance(x,Symbol): return orig_index(x) || orig_index(x.to_s)
    if isinstance(x,String): return orig_index(x) || orig_index(x.to_sym)
    # yay! todo: eqls {a:b}=={:a=>b}=={"a"=>b} !!
    orig_index(x)

  def contains(key):
    keys.contains key


class Array

  def wrap:
    map(&:wrap).join(", ") # leave [] which is not compatible with C

<<<<<<< HEAD
  def values:
    map(&:value).join(", ") # leave [] which is not compatible with C

=======
>>>>>>> 90f860157deaaec63e50c2c1e3ff703d4656df14

  def contains_a(type):
    if isinstance(x,type) }: each{|x| return True
    False

  def drop! x:
    reject! x

  def to_str:
    self.join(", ")

  # ifdef $auto_map:
  def method_missing(method, *args, &block):
    if args.count==0: return self.map { |x| x.send method }
    if args.count>0: return self.map { |x| x.send(method, args) }
    super method, *args, &block

  # def matches(item):
  #   contains item
  # 
  # remove: confusing!!
  def matches(regex):
    for i in self.flatten:
      m=regex.match(i.gsub(r'([^\w])', "\\\\\\1")) #escape_token(i))
      if m:
        return m


    return False

  def and(x):
    if not isinstance(x,Array): self+[x]
    self+x

  def plus(x):
    if not isinstance(x,Array): self+[x]
    self+x

  #EVIL!!
  def blank?:
    None? or empty?

  #def = x  unexpected '=':
  #  is x
  #
  #def grep(x):
  #  select{|y|y.to_s.match(x)}
  #
  def names:
    map &:to_s

  def rest:
    self[1..-1] # last..-1 after index!!!

  def fix_int(i):
    if i.to_s=="middle": i=count/2
    if isinstance(i,Numeric): return i-1
    i=i.to_s.replace_numerals!.to_i
    i-1

  def character(nr):
    item nr

  def item(nr # -1 AppleScript style !!! BUT list[0] !!!):
    self[fix_int nr]

  def word(nr # -1 AppleScript style !!! BUT list[0] !!!):
    self[fix_int nr]

  def invert:
    reverse

  def get(x):
    self[index x]

  def row(n):
    at n

  def has(x):
    index x

  def contains(x):
    ok=index(x)
    ok ? at(index x) : False

  #def to_s:
  #  "["+join(", ")+"]"
  #
class TrueClass
  def blank?:
    False


class FalseClass
  def blank?:
    True

  def wrap:
    self


class String

  def quoted:
    "\"#{self}\""

<<<<<<< HEAD
  def name:
    self

  def id:
    "id(\"#{self}\")"

  def value:
    self  # variable
    # quoted

=======
>>>>>>> 90f860157deaaec63e50c2c1e3ff703d4656df14
  def wrap:
    "s(\"#{self}\")"

  def number:
    self.to_i

  def matches(regex):
    if isinstance(regex,Array):
      regex.each { |x| z=match x;
      if z:
        return x

      )
    else
      match regex

    return False

  def stripNewline:
    strip.sub(r';$', '')

  def join(x):
    self

  # def < x:
  #   i=isinstance(x,Numeric)
  #   if i:
  #     return self.to_i<x
  #   
  #   super.< x
  # 
  def starts_with? x:
    # puts "WARNING: start_with? missspelled as starts_with?"
    if isinstance(x,Array):
      if start_with? y}: x.each{|y| return y

    return start_with? x

  def show(x=None):
    puts x||self
    return x||self

  def contains(*things):
    for t in things.flatten:
      if index(t): return True

    return False

  def fix_int(i):
    if i.to_s=="middle": i=count/2
    if isinstance(i,Numeric): return i-1
    i=i.to_s.replace_numerals!.to_i #if isinstance(i,String):
    i-1

  def sentence(i):
    i=fix_int i
    split(r'[\.\?\!\;]')[i]

  def paragraph(i):
    i=fix_int i
    split("\n")[i]

  def word(i):
    i=fix_int i
    split(" ")[i]

  def item(i):
    word i

  def char(i):
    character i

  def character(i):
    i=fix_int i
    self[i-1..i]

  def flip:
    split(" ").reverse.join(" ")

  def invert:
    reverse

  def plus(x):
    self+x

  def and(x):
    self+x

  def add(x):
    self+x

  def - x:
    self.gsub(x,"")
    # self[0..self.index(x)-1]+self[self.index(x)+x.length..-1]

  def is_noun(# expensive!!!):
    # Sequel::InvalidOperation Invalid argument used for IS operator
    not synsets(:noun).empty? or
        not self.gsub(r's$', "").synsets(:noun).empty? except False

  def is_verb:
    not synsets(:verb).empty? of
    not self.gsub(r's$', "").synsets(:verb).empty?

  def is_a(className):
    className.downcase!
    if className=="quote": return True
    return className=="string"

  def is_adverb:
    not synsets(:adverb).empty?

  def is_adjective:
    not synsets(:adjective).empty?

  def examples:
    synsets.flatten.map(&:hyponyms).flatten.map(&:words).flatten.uniq.map &:to_s

  def blank?:
    None? or empty?

  def lowercase:
    downcase

  def lowercase!:
    downcase!

  def shift(n=1):
    n.times{self.gsub!(r'^.',"")}
    # self[n..-1]

  def replace_numerals!:

    gsub!(r'([a-z])-([a-z])', "\\1+\\2") # WHOOOT???
    # gsub!("last", "-1") # index trick
    gsub!("last", "0") # index trick
    gsub!("first", "1") # index trick

    gsub!("tenth", "10")
    gsub!("ninth", "9")
    gsub!("eighth", "8")
    gsub!("seventh", "7")
    gsub!("sixth", "6")
    gsub!("fifth", "5")
    gsub!("fourth", "4")
    gsub!("third", "3")
    gsub!("second", "2")
    gsub!("first", "1")
    gsub!("zero", "0")

    gsub!("4th", "4")
    gsub!("3rd", "3")
    gsub!("2nd", "2")
    gsub!("1st", "1")
    gsub!("(\d+)th", "\\1")
    gsub!("(\d+)rd", "\\1")
    gsub!("(\d+)nd", "\\1")
    gsub!("(\d+)st", "\\1")

    gsub!("a couple of", "2")
    gsub!("a dozen", "12")
    gsub!("ten", "10")
    gsub!("twenty", "20")
    gsub!("thirty", "30")
    gsub!("forty", "40")
    gsub!("fifty", "50")
    gsub!("sixty", "60")
    gsub!("seventy", "70")
    gsub!("eighty", "80")
    gsub!("ninety", "90")

    gsub!("ten", "10")
    gsub!("eleven", "11")
    gsub!("twelve", "12")
    gsub!("thirteen", "13")
    gsub!("fourteen", "14")
    gsub!("fifteen", "15")
    gsub!("sixteen", "16")
    gsub!("seventeen", "17")
    gsub!("eighteen", "18")
    gsub!("nineteen", "19")

    gsub!("ten", "10")
    gsub!("nine", "9")
    gsub!("eight", "8")
    gsub!("seven", "7")
    gsub!("six", "6")
    gsub!("five", "5")
    gsub!("four", "4")
    gsub!("three", "3")
    gsub!("two", "2")
    gsub!("one", "1")
    gsub!("dozen", "12")
    gsub!("couple", "2")

    gsub!("½", "+1/2.0");
    gsub!("⅓", "+1/3.0");
    gsub!("⅔", "+2/3.0");
    gsub!("¼", "+1/4.0");
    gsub!("¾", "+3/4.0");
    gsub!("⅕", "+1/5.0");
    gsub!("⅖", "+2/5.0");
    gsub!("⅗", "+3/5.0");
    gsub!("⅘", "+4/5.0");
    gsub!("⅙", "+1/6.0");
    gsub!("⅚", "+5/6.0");
    gsub!("⅛", "+1/8.0");
    gsub!("⅜", "+3/8.0");
    gsub!("⅝", "+5/8.0");
    gsub!("⅞", "+7/8.0");


    gsub!(" hundred thousand", " 100000")
    gsub!(" hundred", " 100")
    gsub!(" thousand", " 1000")
    gsub!(" million", " 1000000")
    gsub!(" billion", " 1000000000")
    gsub!("hundred thousand", "*100000")
    gsub!("hundred ", "*100")
    gsub!("thousand ", "*1000")
    gsub!("million ", "*1000000")
    gsub!("billion ", "*1000000000")
    self

  def parse_integer:
    replace_numerals!
    i=eval(self).to_i # except 666
    i

  def parse_number:
    replace_numerals!
    eval(self).to_f

#class Fixnum Float
class Numeric
  def wrap:
    "INT2NUM(#{self.to_s})"

  def number:
    self

  def and(x):
    self+x

  def plus(x):
    self+x

  def minus(x):
    self-x

  def times(x):
    self*x

  def < x:
    if isinstance(x,String): return self<x.to_i
    super.< x

  def blank?:
    return False

  def is_a(clazz):
    className=clazz.to_s.downcase
    if className=="number": return True
    if className=="real": return True
    if className=="float": return True
    if isinstance(self,Integer) and className=="integer" #todo move: return True
    if isinstance(self,Integer) and className=="int" #todo move: return True
    if className==self.to_s.downcase #KINDA: return True
    if self.is clazz: return True
    return False

  def add(x):
    self+x

  def increase(by=1):
    self+by # Can't change the value of numeric self!!

  def decrease(by=1):
    self-by # Can't change the value of numeric self!!

  def bigger? x:
    self>x

  def smaller? x:
    self<x

  def to_the_power_of(x):
    self**x

  def to_the(x):
    self**x

  def logarithm:
    Math.log self

  def e:
    Math.exp self

  def exponential:
    Math.exp self

  def sine:
    Math.sin self

  def cosine:
    Math.cos self

  def root:
    Math.sqrt self

  def power(x):
    self**x

  def square:
    self*self

  # todo: use ^^
  def squared:
    self*self


#if self==False: return True
#if self==True: return False
# class Enumerator

class Object
  def number:
    False

  def blank?:
    False

  def throw(self, x):
    raise x

  def type:
    self.class

  def kind:
    self.class

  def log(*x):
    puts x

  def debug(*x):
    puts x

  def is_a(clazz):
    className = clazz.to_s.downcase
    try:
      ok=isinstance(self,clazz)
      if ok: return True
    except
      puts $!

    if className==self.to_s.downcase #KINDA: return True
    if self.is clazz: return True
    return False

  def is(x):
    if x.blank? and self.blank?: return True
    if x==self: return True
    if x===self: return True
    if x.to_s.downcase==self.to_s.downcase #KINDA: return True
    if isinstance(self,Array) and self.length==1: return True if x.is self[0]
    if isinstance(x,Array) and x.length==1: return True if self.is x[0]
    return False
