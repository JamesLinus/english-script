
# ruby++ better blocks + lambdas !!!
# ruby++ much more forgiving and convenient, i.e. z=map[x] vs if x in map: map[x]
# ruby+ jruby better, class extensions
# ruby+ def 'properties'
# ruby- less modules, more beautiful language => less need for angle!
# ruby-- NO types/type hints!!
# ruby-- no annotations!
# python ++: more modules
# python ++: ironpython ok!
# python ++: type hints (py3)
# python ++: annotations
# python ++: TO/FRO bytecode, NATIVE (sometimes)
# python ++: Ast better integrated(!!)
# python +: list concatenation
# python +-: functions proper(!) 1st class citizens [problem: () not default!]
# python +-: properties
# python +: in operator
# python +: stricter: i.e. ruby z=map[x] (NIL) vs if x in map: map[x]
# python -- LESS FORGIVING! ValueError: list.remove(x): x not in list , if string.index(x): ValueError: substring not found ETC ETC
# python -- missing SO MANY FUNCTIONS! :
# python - unsupported operand type(s) for -: 'list' and 'list', AttributeError: 'list' object has no attribute 'each' ETC **
# python - annoying (self), : , () -> DANGEROUS!! (ok if generated?)
# python - NO class extensions for builtins! (ok with 'macros' / subclass construction (?))
# python --- explicit global/class(self) variable scope nightmare!! lambdas + block variable scope !!!!! 'nonlocal' keyword :(

# both ++ mixins  python:class Request(BaseRequest, AcceptMixin), ruby: include AcceptMixin
# both ++ alias neu alt  python: neu=alt def neu(): alt()

# What separates a mixin from multiple inheritance? Is it just a matter of semantics?
Yes.

 ValueError: list.remove(x): x not in list
** RUBY: # (the.nodes - old_nodes).each(lambda n: n.invalid())
            for fuck in old_nodes:
                if fuck in nodes:
                    nodes.remove(fuck)
            the.nodes.each(lambda n: n.invalid())
             AttributeError: 'list' object has no attribute 'each' WTF -=->
for n in the.nodes: n.invalid()
